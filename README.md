# DesignPatternJ
设计模式(Java)

## 1.简单工厂模式
   比如你买了一条鱼，有煎，炸，烤，煮四种方法吃掉它(方法可能不止这四种，但总是**有限而且不变动**的)，这个时候可以使用简单工厂模式。新建一个“吃法”接口，其中有一个“吃法”的方法，煎，炸，烤，煮分别实现了这个方法，再由一个工厂类封这四个吃法类，我们可以选择任何一种吃法类把这条鱼吃掉。   
   ![简单工厂模式图][1]    
   > 图片来源:[老聚博客][2]   
   - **优点：** 使业务逻辑与界面逻辑分离；通过入参的方式来由工厂类决定实例化哪个对象操作类;   
   - **缺点：** 当操作类变化或增加操作类时，就必须修改工厂类，违反了开放-封闭原则，可以通过反射解决；   
   - **使用场景:** 业务操作与界面表示分离时使用；
## 2.策略模式
   策略模式最常用的场景就是促销活动，乘车方案，角色控制等这样需要经常变换策略的业务。    
   > 策略模式(Strategy)定义了算法家族，分别封装起来，让他们之前可以相互替换，此模式让算法的改变，不影响使用算法的客户。   
   ![策略模式图][3]   
   > 图片来源:[老聚博客][2]   
   - **优点:** 是方便选择算法(操作方法)；   
   - **缺点:** 将算法选择权交给客户，可以通过策略+简单工厂+反射来解决这个问题;   
   - **使用场景:** 对于经常变化操作的业务比较合适
## 3.抽象工厂模式
   一个产品有多套操作方案，每一种方案下可以有对该产品的多种操作方法。这个时候需要使用抽象工厂模式，可以随时在多种方案之间切换。   
   ![抽象工厂设计模式][4]   
   > 图片来源:大话设计模式-程杰   
   - **优点:** 可以方便在多个产品实现方案之间切换   
   - **缺点:** 如果增加操作对象，则修改的范围比较大   
   - **使用场景:** 产品需要有多种实现方案时
## 4.装饰模式   
动态地给一个对象增加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。   
![装饰模式][5]    
> 图片来源:大话设计模式-程杰   
- **优点:** 不改变对象本身情况下，很容易地对对象进行一些操作，并可以任意决定操作的顺序;每个装饰类只需要关心自己的功能，不需要知道是否有其它装饰类存在以及与它们的关系如何 
- **缺点:** 可能会产生许多相似的装修功能小类;由客户端决定装饰顺序，可能会不安全。   
- **使用场景:** 对象首先具有一定的核心功能，其它功能都是随时可以增加或删除时,可以选择使用装饰模式

[1]: http://pic002.cnblogs.com/images/2012/155937/2012070214562479.png "简单工厂模式图"
[2]: http://www.cnblogs.com/wangjq/
[3]: http://pic002.cnblogs.com/images/2012/155937/2012070310013466.png "策略模式图"
[4]: http://wx3.sinaimg.cn/mw690/9cac8bffly1fha4khgq39j20nn0i0ju5.jpg "抽象工厂设计模式"   
[5]: http://wx1.sinaimg.cn/mw690/9cac8bffly1fhqg8zrhp1j20qq0f9498.jpg  "装饰模式"


